<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · RegularizationTools.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RegularizationTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">RegularizationTools.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../theory/theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Constructor-Functions"><span>Constructor Functions</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Validators"><span>Validators</span></a></li><li><a class="tocitem" href="#Generic-Functions"><span>Generic Functions</span></a></li><li><a class="tocitem" href="#High-Level-API"><span>High-Level API</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mdpetters/RegularizationTools.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Types"><a class="docs-heading-anchor" href="#Data-Types">Data Types</a><a id="Data-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Types" title="Permalink"></a></h1><h3 id="RegularizationProblem"><a class="docs-heading-anchor" href="#RegularizationProblem">RegularizationProblem</a><a id="RegularizationProblem-1"></a><a class="docs-heading-anchor-permalink" href="#RegularizationProblem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.RegularizationProblem" href="#RegularizationTools.RegularizationProblem"><code>RegularizationTools.RegularizationProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizationProblem</code></pre><p>This data type contains the cached matrices used in the inversion. The problem is  initialized using the constructor <a href="#setupRegularizationProblem">setupRegularizationProblem</a> with the design matrix  A and the the Tikhonv matrix L as inputs. The hat quantities, e.g. Ā, is the calculated design matrix in standard form. ĀĀ, Āᵀ, F̄ are precomputed to speed up repeating inversions with different data. L⁺ₐ is cached to speed up the repeated conversion of  data <a href="#to_standard_form">to_standard_form</a> and <a href="#to_general_form">to_general_form</a></p><pre><code class="language-none">Ā::Matrix{Float64}     # Standard form of design matrix
A::Matrix{Float64}     # General form of the design matrix (n×p)
L::Matrix{Float64}     # Smoothing matrix (n×p)
ĀĀ::Matrix{Float64}    # Cached value of Ā&#39;Ā for performance
Āᵀ::Matrix{Float64}    # Cached value of Ā&#39; for performance
F̄::SVD                 # Cached SVD decomposition of Ā 
Iₙ::Matrix{Float64}    # Cached identity matrix n×n
Iₚ::Matrix{Float64}    # Cached identity matrix p×p
L⁺ₐ::Matrix{Float64}   # Cached A-weighted generalized inverse of L(standard-form conversion)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/RegularizationTools.jl#L35-L54">source</a></section></article><h3 id="RegularizatedSolution"><a class="docs-heading-anchor" href="#RegularizatedSolution">RegularizatedSolution</a><a id="RegularizatedSolution-1"></a><a class="docs-heading-anchor-permalink" href="#RegularizatedSolution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.RegularizedSolution" href="#RegularizationTools.RegularizedSolution"><code>RegularizationTools.RegularizedSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizatedSolution</code></pre><p>Data tpye to store the optimal solution x of the inversion. λ is the optimal λ used  solution is the raw output from the Optim search.</p><pre><code class="language-none">x::AbstractVector
λ::AbstractFloat
solution::Optim.UnivariateOptimizationResults</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/RegularizationTools.jl#L67-L76">source</a></section></article><h3 id="Domain"><a class="docs-heading-anchor" href="#Domain">Domain</a><a id="Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Domain" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Domain" href="#RegularizationTools.Domain"><code>RegularizationTools.Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Domain{T1&lt;:Any,T2&lt;:Number,T3&lt;:Any}</code></pre><p>Functor to map from a domain characterized by a list of setpoints [s], each  associated with a list of numerical values [x] to a query value q. </p><pre><code class="language-none">s::AbstractVector{T1}
x::AbstractVector{T2}
q::T3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/RegularizationTools.jl#L83-L92">source</a></section></article><h2 id="Constructor-Functions"><a class="docs-heading-anchor" href="#Constructor-Functions">Constructor Functions</a><a id="Constructor-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-Functions" title="Permalink"></a></h2><h3 id="Tikhonov-Matrix"><a class="docs-heading-anchor" href="#Tikhonov-Matrix">Tikhonov Matrix</a><a id="Tikhonov-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Tikhonov-Matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Γ" href="#RegularizationTools.Γ"><code>RegularizationTools.Γ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Γ(A::AbstractMatrix, order::Int)</code></pre><p>Return the smoothing matrix L for zero, first and second order Tikhonov regularization  based on the size of design matrix A. Order can be 0, 1 or 2.</p><pre><code class="language-julia">L = Γ(A, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L1-L10">source</a></section></article><h3 id="setupRegularizationProblem"><a class="docs-heading-anchor" href="#setupRegularizationProblem">setupRegularizationProblem</a><a id="setupRegularizationProblem-1"></a><a class="docs-heading-anchor-permalink" href="#setupRegularizationProblem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.setupRegularizationProblem" href="#RegularizationTools.setupRegularizationProblem"><code>RegularizationTools.setupRegularizationProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setupRegularizationProblem(A::AbstractMatrix, order::Int)</code></pre><p>Precompute matrices to initialize Reguluarization Problem based on design matrix A and  zeroth, first, or second order difference operator. See Hanson (1998) and source code for details.</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, 0) # zeroth order problem
Ψ = setupRegularizationProblem(A, 2) # second order problem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L379-L391">source</a></section><section><div><pre><code class="language-none">setupRegularizationProblem(A::AbstractMatrix, L::AbstractMatrix)</code></pre><p>Precompute matrices to initialize Reguluarization Problem based on design matrix and  Tikhonov smoothing matrix. See Hansen (1998, Eq. 2.35)</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, L) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L10">source</a></section></article><h3 id="to_standard_form"><a class="docs-heading-anchor" href="#to_standard_form">to_standard_form</a><a id="to_standard_form-1"></a><a class="docs-heading-anchor-permalink" href="#to_standard_form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.to_standard_form" href="#RegularizationTools.to_standard_form"><code>RegularizationTools.to_standard_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_standard_form(Ψ::RegularizationProblem, b::AbstractVector)</code></pre><p>Converts vector b to standard form using (Hansen, 1998)</p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia">b̄ = to_standard_form(Ψ, b)</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia">b̄ = @&gt;&gt; b to_standard_form(Ψ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L52-L66">source</a></section><section><div><pre><code class="language-none">to_standard_form(Ψ::RegularizationProblem, b::AbstractVector, x₀::AbstractVector)</code></pre><p>Converts vector b and x₀ to standard form using (Hansen, 1998)</p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia">b̄ = to_standard_form(Ψ, b, x₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L69-L78">source</a></section></article><h3 id="to_general_form"><a class="docs-heading-anchor" href="#to_general_form">to_general_form</a><a id="to_general_form-1"></a><a class="docs-heading-anchor-permalink" href="#to_general_form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.to_general_form" href="#RegularizationTools.to_general_form"><code>RegularizationTools.to_general_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_general_form(Ψ::RegularizationProblem, b::AbstractVector, x̄::AbstractVector)</code></pre><p>Converts solution <span>$\bar {\rm x}$</span> computed in standard form back to general form  <span>${\rm x}$</span> using (Hansen, 1998). Solution is truncated to regularized space, given by the matrix L. If L is p × n and p &lt; n, then only the solution 1:p is valid. The remaining  parameters can be estiamted from the least-squares solution if needed.</p><p class="math-container">\[{\rm x}={\rm {\bf L^{+}_A}\bar{x}}\]</p><p>where the matrices and vectors are defined in <a href="#RegularizationProblem">RegularizationProblem</a></p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia">x = to_general_form(Ψ, b, x̄) </code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia">x = @&gt;&gt; x̄ to_general_form(Ψ, b) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L82-L105">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><h3 id="solve"><a class="docs-heading-anchor" href="#solve">solve</a><a id="solve-1"></a><a class="docs-heading-anchor-permalink" href="#solve" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.solve" href="#RegularizationTools.solve"><code>RegularizationTools.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the Tikhonov solution for problem Ψ in standard form for regularization parameter λ and using zero as initial guess. Returns a vector <span>$\rm {\bar x}_\lambda$</span>. </p><p class="math-container">\[{\rm x_{\lambda}}=\left({\rm {\bf \bar A}^{T}}{\rm {\bf \bar A}}+\lambda^{2}{\rm {\bf I}}\right)^{-1} 
{\rm {\bf {\bar A}}^{T}}{\rm {\bar b}} \]</p><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 1)     # Setup problem
b̄ = to_standard_form(Ψ, b)               # Convert to standard form
x̄ = solve(A, b̄, 0.5)                     # Solve the equation
x = to_general_form(Ψ, b, x̄)             # Convert back to general form</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 1)     # Setup problem
b̄ = @&gt;&gt; b to_standard_form(Ψ)            # Convert to standard form
x̄ = solve(A, b̄, 0.5)                     # Solve the equation
x = @&gt;&gt; x̄ to_general_form(Ψ, b)          # Convert back to general form</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L116-L143">source</a></section><section><div><pre><code class="language-none">solve(Ψ::RegularizationProblem, b̄::AbstractVector, x̄₀::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the Tikhonov solution for problem Ψ in standard form for regularization parameter λ and using x̄₀ as initial guess. </p><p class="math-container">\[{\rm x_{\lambda}}=\left({\rm {\bf \bar A}^{T}}{\rm {\bf \bar A}}+\lambda^{2}{\rm {\bf I}}\right)^{-1} 
\left({\rm {\bf {\bar A}}^{T}}{\rm {\bar b}} + \lambda^2 {\rm {\bar x}}_0 \right)\]</p><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 2)     # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)       # Convert to standard form
x̄ = solve(A, b̄, x̄₀, 0.5)                 # Solve the equation
x = to_general_form(Ψ, b, x̄)             # Convert back to general form</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L150-L169">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem,
    b::AbstractVector;
    alg = :gcv_svd,
    λ₁ = 0.0001,
    λ₂ = 1000.0,
)</code></pre><p>Find the optimum regularization parameter λ between [λ₁, λ₂] using the algorithm alg. Choices for algorithms are</p><pre><code class="language-none">    :gcv_tr - generalized cross validation using the trace formulation (slow)
    :gcv_svd - generalized cross validation using the SVD decomposition (fast)
    :L_curve - L-curve algorithm </code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The gcv_svd algorithm is fastest and most stable. The L_curve algorithn is sensitive to the upper  and lower bound. Specify narrow upper and lower bounds to obtain a good solution.</p></div></div><p>The solve function takes the original data, converts it to standard form, performs the search within the specified bounds and returns a <a href="#RegularizatedSolution">RegularizatedSolution</a></p><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 2)     # Setup problem
sol = solve(Ψ, b)                        # Solve it</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
sol = @&gt; setupRegularizationProblem(A, 1) solve(b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L176-L212">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem,
    b::AbstractVector,
    x₀::AbstractVector;
    alg = :gcv_svd,
    λ₁ = 0.0001,
    λ₂ = 1000.0,
)</code></pre><p>Same as above, but includes an initial guess x₀. Example Usage (Lazy Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
sol = @&gt; setupRegularizationProblem(A, 1) solve(b, x₀, alg = :L_curve, λ₂ = 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L237-L252">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem, 
    b::AbstractVector,
    lower::AbstractVector, 
    upper::AbstractVector;
    kwargs...
)</code></pre><p>Constraint minimization of <a href="#RegularizationProblem">RegularizationProblem</a> Ψ, with observations b and upper and lower bounds for each xᵢ.</p><p>The function computes the algebraic solution using <code>solve(Ψ, b; kwargs...)</code>, truncates the solution at the upper and lower bounds and uses this solution as initial condition for the minimization problem using a Least Squares numerical solver. The returned solution is using the regularization parameter λ obtained from the algebraic solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L279-L295">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem, 
    b::AbstractVector,
    x₀::AbstractVector,
    lower::AbstractVector, 
    upper::AbstractVector;
    kwargs...
)</code></pre><p>Constraint minimization of <a href="#RegularizationProblem">RegularizationProblem</a> Ψ, with observations b, intial  guess x₀ and upper and lower bounds for each xᵢ.</p><p>The function computes the algebraic solution using <code>solve(Ψ, b; kwargs...)</code>, truncates the solution at the upper and lower bounds and uses this solution as initial condition for the minimization problem using a Least Squares numerical solver. The returned solution is using the regularization parameter λ obtained from the algebraic solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/solvers.jl#L306-L324">source</a></section></article><h2 id="Validators"><a class="docs-heading-anchor" href="#Validators">Validators</a><a id="Validators-1"></a><a class="docs-heading-anchor-permalink" href="#Validators" title="Permalink"></a></h2><h3 id="GCV"><a class="docs-heading-anchor" href="#GCV">GCV</a><a id="GCV-1"></a><a class="docs-heading-anchor-permalink" href="#GCV" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.gcv_tr" href="#RegularizationTools.gcv_tr"><code>RegularizationTools.gcv_tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gcv_tr(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term. Requires that the  vector b̄ is in standard form.</p><p class="math-container">\[V(\lambda)=\frac{n\left\lVert ({\bf {\rm {\bf {\bf I}-}{\bf \bar {A}_{\lambda}})
{\bar{\rm b}}}}\right\rVert _{2}^{2}}{tr({\rm {\bf I}-{\rm {\bar {\bf A}_{\lambda}})}^{2}}}\]</p><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)           # Setup problem
b̄ = to_standard_form(Ψ, b)                     # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/validators.jl#L1-L21">source</a></section><section><div><pre><code class="language-none">gcv_tr(
    Ψ::RegularizationProblem,
    b̄::AbstractVector,
    x̄₀::AbstractVector,
    λ::AbstractFloat,
)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term and intial guess.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p class="math-container">\[V(\lambda)=\frac{n\left\lVert {\bf {\rm {\bf \bar{A}}{\rm \bar{x}{}_{\lambda}}-
{\rm \bar{b}}}}\right\rVert _{2}^{2}}{tr({\rm {\bf I}-{\rm {\bar {\bf A}_{\lambda}})}^{2}}}\]</p><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)               # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, x̄₀, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, x̄₀, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/validators.jl#L30-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.gcv_svd" href="#RegularizationTools.gcv_svd"><code>RegularizationTools.gcv_svd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gcv_svd(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term using the SVD  algorithm. Requires that the vector b̄ is in standard form.</p><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)            # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)              # Convert to standard form
Vλ = gcv_svd(Ψ, b̄, x̄₀, 0.1)                     # V(λ) single λ value
Vλ = @_ map(gcv_svd(Ψ, b̄, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/validators.jl#L69-L84">source</a></section><section><div><pre><code class="language-none">gcv_svd(
    Ψ::RegularizationProblem,
    b̄::AbstractVector,
    x̄₀::AbstractVector,
    λ::AbstractFloat,
)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the SVD algorithm and intial guess.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)               # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, x̄₀, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, x̄₀, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/validators.jl#L104-L124">source</a></section></article><h3 id="L-curve-Functions"><a class="docs-heading-anchor" href="#L-curve-Functions">L-curve Functions</a><a id="L-curve-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#L-curve-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Lcurve_functions" href="#RegularizationTools.Lcurve_functions"><code>RegularizationTools.Lcurve_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lcurve_functions(Ψ::RegularizationProblem, b̄::AbstractVector)</code></pre><p>Compute the L-curve functions to evaluate the norms L1, L2, and the curvature κ.  Requires that the vectors b̄ is in standard form.</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, 1)
b̄ = to_standard_form(Ψ, b)
L1norm, L2norm, κ = Lcurve_functions(Ψ, b̄)

L1norm.([0.1, 1.0, 10.0])    # L1 norm for λ&#39;s
L2norm.([0.1, 1.0, 10.0])    # L2 norm for λ&#39;s
κ.([0.1, 1.0, 10.0])         # L-curve curvature for λ&#39;s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/validators.jl#L162-L179">source</a></section><section><div><pre><code class="language-none">Lcurve_functions(Ψ::RegularizationProblem, b̄::AbstractVector, x̄₀::AbstractVector)</code></pre><p>Compute the L-curve functions to evaluate the norms L1, L2, and the curvature κ.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, 1)
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 
L1norm, L2norm, κ = Lcurve_functions(Ψ, b̄, x̄₀)

L1norm.([0.1, 1.0, 10.0])    # L1 norm for λ&#39;s
L2norm.([0.1, 1.0, 10.0])    # L2 norm for λ&#39;s
κ.([0.1, 1.0, 10.0])         # L-curve curvature for λ&#39;s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/validators.jl#L187-L203">source</a></section></article><h2 id="Generic-Functions"><a class="docs-heading-anchor" href="#Generic-Functions">Generic Functions</a><a id="Generic-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Functions" title="Permalink"></a></h2><h3 id="designmatrix"><a class="docs-heading-anchor" href="#designmatrix">designmatrix</a><a id="designmatrix-1"></a><a class="docs-heading-anchor-permalink" href="#designmatrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.designmatrix" href="#RegularizationTools.designmatrix"><code>RegularizationTools.designmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">designmatrix(s::Any, q::Any, f::Function)::AbstractMatrix</code></pre><ul><li>s is an array of setpoints</li><li>q is an array of query points</li><li>f is a function that maps the functor <a href="#Domain">Domain</a> to a solution y</li></ul><p>The function to creates an array of domain nodes using the standard basis eᵢ of  the vector space. The setpoint or query point can be any abstract notion of the  input. For examples, a numerical value corresponding to a setting, a string label  ([&quot;bin A&quot;, &quot;bin B&quot;, ...), or a list of pixel coordinate [(1,1), (1,2), ...].  The function f must accept a single argument of type <a href="#Domain">Domain</a> and provide a  numerical mapping between input <span>$x$</span> and output <span>$y$</span> at query point <span>$q$</span>. The function designmatrix then returns a design matrix <span>$\mathbf{A}$</span> such that </p><p><span>$y = \mathbf{A}x$</span></p><p>where x is an array of numerical input values. In the case that [q] = [s], the  shortcut <code>designmatrix(s, f)</code> can be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/genericfunctions.jl#L1-L22">source</a></section></article><h3 id="forwardmodel"><a class="docs-heading-anchor" href="#forwardmodel">forwardmodel</a><a id="forwardmodel-1"></a><a class="docs-heading-anchor-permalink" href="#forwardmodel" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.forwardmodel" href="#RegularizationTools.forwardmodel"><code>RegularizationTools.forwardmodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">forwardmodel(
    s::AbstractVector{T1},
    x::AbstractVector{T2},
    f::Function,
)::AbstractArray where {T1&lt;:Any,T2&lt;:Number}</code></pre><p>Forward model that maps numerical values [x] corresponding to  setpoints [s] to output [y], given the function f. The function f must  accept a single argument of type <a href="#Domain">Domain</a> and provide a  numerical mapping between input <span>$x$</span> and output <span>$y$</span> at query point <span>$q$</span>.</p><p>Note that the <a href="#designmatrix">designmatrix</a> and forward model are related</p><p>``` A = designmatrix(s, q, f) y1 = A*x</p><p>y2 = forwardmodel(s, x, q, f) y1 == y2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/genericfunctions.jl#L32-L52">source</a></section></article><h2 id="High-Level-API"><a class="docs-heading-anchor" href="#High-Level-API">High-Level API</a><a id="High-Level-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-API" title="Permalink"></a></h2><h3 id="invert"><a class="docs-heading-anchor" href="#invert">invert</a><a id="invert-1"></a><a class="docs-heading-anchor-permalink" href="#invert" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.invert" href="#RegularizationTools.invert"><code>RegularizationTools.invert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function invert(A::Matrix, b::Vector, method::InverseMethod; kwargs...)</code></pre><p>High-level API function to perform Tikhonov inversion. The function used  the algebraic data type InverseMethod</p><pre><code class="language-julia">    @data InverseMethod begin 
        Lₖ(Int)                            # Pure Tikhonov
        Lₖx₀(Int,Vector)                   # with initial guess
        LₖB(Int,Vector,Vector)             # with bounds
        Lₖx₀B(Int,Vector,Vector,Vector)    # with initial guess + bounds
        LₖDₓ(Int,Float64)                  # with filter 
        Lₖx₀Dₓ(Int,Vector,Float64)         # with initial guess + filter 
        LₖDₓB(Int,Float64,Vector,Vector)   # with filter + bound
        Lₖx₀DₓB(Int,Vector,Float64,Vector,Vector) # with initial guess + filter + bound
    end</code></pre><p>to define the problem and then dispatches to the correct method. The kwargs... are passed to the solve function For example the standard way to perform second order regularization is </p><pre><code class="language-julia">xλ = @&gt; setupRegularizationProblem(A, 2) solve(b) getfield(:x)</code></pre><p>this can alternativel written as </p><pre><code class="language-julia">invert(A, b, Lₖ(2))</code></pre><p>where <code>Lₖ(2)</code> denotes the second order method. The method nomenclature is <code>Lₖ</code> for regularization order, <code>B</code> for bounded search, <code>x₀</code> for  initial condition, and <code>Dₓ</code> for the Huckle and Sedlacek (2012) two-step data based  regularization. The method data type takes hyper parameters to initialize the search.  Examples of method initializations are</p><pre><code class="language-julia"># Hyper parameters 
k: order, lb: low bound, ub: upper bound, ε: noise level, x₀: initial guess
k, lb, ub, ε, x₀ = 2, zeros(8), zeros(8) .+ 50.0, 0.02, 0.5*N

xλ = invert(A, b, Lₖ(k); alg = :gcv_tr, λ₁ = 0.1)
xλ = invert(A, b, Lₖ(k); alg = :gcv_svd, λ₁ = 0.1)
xλ = invert(A, b, LₖB(k, lb, ub); alg = :L_curve, λ₁ = 0.1)
xλ = invert(A, b, Lₖx₀(k, x₀); alg = :L_curve, λ₁ = 0.1)
xλ = invert(A, b, Lₖx₀(k, x₀); alg = :gcv_tr)
xλ = invert(A, b, Lₖx₀(k, x₀); alg = :gcv_svd)
xλ = invert(A, b, Lₖx₀B(k, x₀, lb, ub); alg = :gcv_svd)
xλ = invert(A, b, LₖDₓ(k, ε); alg = :gcv_svd)
xλ = invert(A, b, LₖDₓB(k, ε, lb, ub); alg = :gcv_svd)
xλ = invert(A, b, Lₖx₀Dₓ(k, x₀, ε); alg = :gcv_svd)
xλ = invert(A, b, Lₖx₀DₓB(k, x₀, ε, lb, ub); alg = :gcv_svd)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/1905a2103916e1a628e32a7ee7ab0f4fb7000fe6/src/invert.jl#L1-L56">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/theory/">« Theory</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 December 2020 16:04">Tuesday 8 December 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
